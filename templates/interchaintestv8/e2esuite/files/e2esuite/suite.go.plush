package e2esuite

import (
	"context"

	dockerclient "github.com/docker/docker/client"
	"github.com/stretchr/testify/suite"
	"go.uber.org/zap"
	"go.uber.org/zap/zaptest"
<%= if (ChainNum > 1) { %>
	interchaintest "github.com/strangelove-ventures/interchaintest/v8"
	"github.com/strangelove-ventures/interchaintest/v8/chain/cosmos"
	"github.com/strangelove-ventures/interchaintest/v8/ibc"
	"github.com/strangelove-ventures/interchaintest/v8/relayer"
	"github.com/strangelove-ventures/interchaintest/v8/testreporter"
	"github.com/strangelove-ventures/interchaintest/v8/testutil"
<% } else { %>
	interchaintest "github.com/strangelove-ventures/interchaintest/v8"
	"github.com/strangelove-ventures/interchaintest/v8/chain/cosmos"
	"github.com/strangelove-ventures/interchaintest/v8/ibc"
<% } %>
	"<%= ModulePath %>/chainconfig"
)

// TestSuite is a suite of tests that require two chains and a relayer
type TestSuite struct {
	suite.Suite
<%= if (ChainNum > 1) { %>
	<%= for (n) in between(0, ChainNum) { %>Chain<%= numToLetter(n) %>       *cosmos.CosmosChain
	<% } %><%= for (n) in between(0, ChainNum) { %>User<%= numToLetter(n) %>        ibc.Wallet
	<% } %>dockerClient *dockerclient.Client
	Relayer      ibc.Relayer
	network      string
	logger       *zap.Logger
	ExecRep      *testreporter.RelayerExecReporter
	// Name of the path from ChainA to ChainB
	PathName string
<% } else { %>
	ChainA       *cosmos.CosmosChain
	UserA        ibc.Wallet
	dockerClient *dockerclient.Client
	network      string
	logger       *zap.Logger
<% } %>}

// SetupSuite sets up the chains, relayer, user accounts, clients, and connections
func (s *TestSuite) SetupSuite(ctx context.Context) {
	chainSpecs := chainconfig.DefaultChainSpecs

	if len(chainSpecs) != <%= ChainNum %> {
		panic("TestSuite requires exactly <%= ChainNum %> chain specs")
	}

	t := s.T()

	s.logger = zaptest.NewLogger(t)
	s.dockerClient, s.network = interchaintest.DockerSetup(t)

	cf := interchaintest.NewBuiltinChainFactory(s.logger, chainSpecs)

	chains, err := cf.Chains(t.Name())
	s.Require().NoError(err)
<%= for (n) in between(0, ChainNum) { %>	s.Chain<%= numToLetter(n) %> = chains[<%= n %>].(*cosmos.CosmosChain)
<% } %>
<%= if (ChainNum > 1) { %>	// docker run -it --rm --entrypoint echo ghcr.io/cosmos/relayer "$(id -u):$(id -g)"
	goRelayerImage := relayer.CustomDockerImage(goRelayerImage, goRelayerTag, goRelayerUidGid)

	s.Relayer = interchaintest.NewBuiltinRelayerFactory(
		ibc.CosmosRly,
		zaptest.NewLogger(t),
		goRelayerImage,
	).Build(t, s.dockerClient, s.network)

	s.ExecRep = testreporter.NewNopReporter().RelayerExecReporter(t)

	s.PathName = s.ChainA.Config().Name + "-" + s.ChainB.Config().Name
	ic := interchaintest.NewInterchain().
		<%= for (n) in between(0, ChainNum) { %>AddChain(s.Chain<%= numToLetter(n) %>).
		<% } %>AddRelayer(s.Relayer, "relayer").
		AddLink(interchaintest.InterchainLink{
			Chain1:  s.ChainA,
			Chain2:  s.ChainB,
			Relayer: s.Relayer,
			Path:    s.PathName,
		})
<% } else { %>	ic := interchaintest.NewInterchain().AddChain(s.ChainA)
<% } %>
	s.Require().NoError(ic.Build(ctx, nil, interchaintest.InterchainBuildOptions{
		TestName:         t.Name(),
		Client:           s.dockerClient,
		NetworkID:        s.network,
		SkipPathCreation: true,
	}))

	// map all query request types to their gRPC method paths
<%= for (n) in between(0, ChainNum) { %>	s.Require().NoError(populateQueryReqToPath(ctx, s.Chain<%= numToLetter(n) %>))
<% } %>
	// Fund a user accounts
	const userFunds = int64(10_000_000_000)
	users := interchaintest.GetAndFundTestUsers(t, ctx, t.Name(), userFunds<%= for (n) in between(0, ChainNum) { return ", s.Chain" + numToLetter(n) } %>)
<%= for (n) in between(0, ChainNum) { %>	s.User<%= numToLetter(n) %> = users[<%= n %>]
<% } %><%= if (ChainNum > 1) { %>
	// Generate a new IBC path
	err = s.Relayer.GeneratePath(ctx, s.ExecRep, s.ChainA.Config().ChainID, s.ChainB.Config().ChainID, s.PathName)
	s.Require().NoError(err)

	// Create new clients
	err = s.Relayer.CreateClients(ctx, s.ExecRep, s.PathName, ibc.CreateClientOptions{TrustingPeriod: "330h"})
	s.Require().NoError(err)

	err = testutil.WaitForBlocks(ctx, 2, s.ChainA, s.ChainB)
	s.Require().NoError(err)

	// Create a new connection
	err = s.Relayer.CreateConnections(ctx, s.ExecRep, s.PathName)
	s.Require().NoError(err)

	err = testutil.WaitForBlocks(ctx, 2, s.ChainA, s.ChainB)
	s.Require().NoError(err)

	// Query for the newly created connection in wasmd
	connections, err := s.Relayer.GetConnections(ctx, s.ExecRep, s.ChainA.Config().ChainID)
	s.Require().NoError(err)
	// localhost is always a connection since ibc-go v7.1+
	s.Require().Equal(2, len(connections))
	wasmdConnection := connections[0]
	s.Require().NotEqual("connection-localhost", wasmdConnection.ID)

	// Query for the newly created connection in simd
	connections, err = s.Relayer.GetConnections(ctx, s.ExecRep, s.ChainB.Config().ChainID)
	s.Require().NoError(err)
	// localhost is always a connection since ibc-go v7.1+
	s.Require().Equal(2, len(connections))
	simdConnection := connections[0]
	s.Require().NotEqual("connection-localhost", simdConnection.ID)

	// Start the relayer and set the cleanup function.
	err = s.Relayer.StartRelayer(ctx, s.ExecRep, s.PathName)
	s.Require().NoError(err)

	t.Cleanup(
		func() {
			err := s.Relayer.StopRelayer(ctx, s.ExecRep)
			if err != nil {
				t.Logf("an error occurred while stopping the relayer: %s", err)
			}

			// Collect diagnostics
			chains := []string{chainSpecs[0].ChainConfig.Name<%= for (n) in between(1, ChainNum) { return ", chainSpecs[" + n + "].ChainConfig.Name" } %>}
			collect(t, s.dockerClient, true, chains...)
		},
	)
<% } else { %>
	t.Cleanup(
		func() {
			// Collect diagnostics
			chains := []string{chainSpecs[0].ChainConfig.Name}
			collect(t, s.dockerClient, true, chains...)
		},
	)
<% } %>}
