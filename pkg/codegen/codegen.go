package codegen

import (
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/srdtrk/go-codegen/pkg/schemas"
	"github.com/srdtrk/go-codegen/pkg/types"
)

func GenerateCodeFromIDLSchema(idlSchema *schemas.IDLSchema, outputPath string, packageName string) error {
	if idlSchema == nil {
		panic("idlSchema is nil")
	}

	if packageName == "" {
		if idlSchema.ContractName == "" {
			panic("no contract name")
		}

		packageName = idlSchema.ContractName
	}

	if !strings.HasSuffix(outputPath, ".go") {
		panic("output path must end with .go")
	}

	nonAlphabeticRegex := regexp.MustCompile(`[^a-zA-Z ]+`)
	packageName = nonAlphabeticRegex.ReplaceAllString(packageName, "")

	f := jen.NewFile(packageName)
	f.PackageComment("/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */")

	if idlSchema.Instantiate == nil {
		panic("no InstantiateMsg schema")
	}

	GenerateInstantiateMsg(f, idlSchema.Instantiate)
	GenerateExecuteMsg(f, idlSchema.Execute)
	GenerateSudoMsg(f, idlSchema.Sudo)
	GenerateMigrateMsg(f, idlSchema.Migrate)
	GenerateQueryMsg(f, idlSchema.Query)
	GenerateResponses(f, idlSchema.Responses)

	types.DefaultLogger().Info().Msgf("Generating code to %s", outputPath)
	generateDefinitions(f)

	if err := f.Save(outputPath); err != nil {
		return err
	}

	types.DefaultLogger().Info().Msgf("✨ All done! ✨")
	return nil
}
