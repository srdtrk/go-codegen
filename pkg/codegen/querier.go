package codegen

import (
	"fmt"
	"regexp"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"

	"github.com/srdtrk/go-codegen/pkg/schemas"
	"github.com/srdtrk/go-codegen/pkg/types"
)

// GenerateQueryClientFromIDLSchema generates a gRPC query client for your CosmWasm smart contracts.
func GenerateQueryClientFromIDLSchema(schemaPath, outputPath, packageName string) error {
	idlSchema, err := schemas.IDLSchemaFromFile(schemaPath)
	if err != nil {
		return err
	}

	if packageName == "" {
		if idlSchema.ContractName == "" {
			panic("no contract name")
		}

		packageName = idlSchema.ContractName
	}

	if !strings.HasSuffix(outputPath, ".go") {
		panic("output path must end with .go")
	}

	nonAlphanumericRegex := regexp.MustCompile(`[^a-zA-Z0-9 ]+`)
	packageName = nonAlphanumericRegex.ReplaceAllString(packageName, "")
	packageName = strings.ToLower(packageName)

	f := jen.NewFile(packageName)
	f.PackageComment("/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */")

	if idlSchema.Instantiate == nil {
		panic("no InstantiateMsg schema")
	}

	GenerateQueryClient(f, idlSchema.Responses, idlSchema.Query)

	types.DefaultLogger().Info().Msgf("Generating query client to %s", outputPath)
	generateDefinitions(f)

	if err := f.Save(outputPath); err != nil {
		return err
	}

	types.DefaultLogger().Info().Msgf("✨ All done! ✨")
	return nil
}

// GenerateQueryClient generates the gRPC query client for your CosmWasm smart contracts.
func GenerateQueryClient(f *jen.File, responses map[string]*schemas.JSONSchema, queryMsgSchema *schemas.JSONSchema) {
	queryTitle := queryMsgSchema.Title
	methods := []jen.Code{}

	for queryName, respSchema := range responses {
		methods = append(methods, generateQueryInterfaceFunc(queryTitle, queryName, respSchema)...)
	}

	f.Comment("QueryClient is the client API for Query service.")
	f.Comment("")
	f.Comment("For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.")
	f.Type().Id("QueryClient").Interface(methods...)

	f.Line()

	f.Type().Id("queryClient").Struct(
		jen.Id("cc").Op("*").Qual("google.golang.org/grpc", "ClientConn"),
		jen.Id("address").String(),
	)

	f.Var().Id("_").Id("QueryClient").Op("=").Parens(jen.Op("*").Id("queryClient")).Parens(jen.Nil())

	f.Comment("NewQueryClient creates a new QueryClient")
	f.Func().Id("NewQueryClient").Params(
		jen.Id("gRPCAddress"),
		jen.Id("contractAddress").String(),
		jen.Id("opts").Op("...").Qual("google.golang.org/grpc", "DialOption"),
	).Params(jen.Id("QueryClient"), jen.Error()).Block(
		jen.If(jen.Len(jen.Id("opts")).Op("==").Lit(0)).Block(
			jen.Id("opts").Op("=").Append(jen.Id("opts"), jen.Qual("google.golang.org/grpc", "WithTransportCredentials").Call(jen.Qual("google.golang.org/grpc/credentials/insecure", "NewCredentials").Call())),
		),
		jen.Line(),
		jen.Comment("Create a connection to the gRPC server"),
		jen.List(jen.Id("grpcConn"), jen.Err()).Op(":=").Qual("google.golang.org/grpc", "Dial").Call(jen.Id("gRPCAddress"), jen.Id("opts").Op("...")),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Line(),
		jen.Return(jen.Op("&").Id("queryClient").Values(jen.Dict{
			jen.Id("cc"):      jen.Id("grpcConn"),
			jen.Id("address"): jen.Id("contractAddress"),
		}), jen.Nil()),
	)

	f.Comment("Close closes the gRPC connection to the server")
	f.Func().Params(jen.Id("q").Op("*").Id("queryClient")).Id("Close").Params().Error().Block(
		jen.Return(jen.Id("q").Dot("cc").Dot("Close").Call()),
	)

	f.ImportAlias("github.com/CosmWasm/wasmd/x/wasm/types", "wasmtypes")
	f.Comment("queryContract is a helper function to query the contract with raw query data")
	f.Func().Params(jen.Id("q").Op("*").Id("queryClient")).Id("queryContract").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("rawQueryData").Index().Byte(),
		jen.Id("opts").Op("...").Qual("google.golang.org/grpc", "CallOption"),
	).Params(jen.Index().Byte(), jen.Error()).Block(
		jen.Id("in").Op(":=").Op("&").Qual("github.com/CosmWasm/wasmd/x/wasm/types", "QuerySmartContractStateRequest").Values(jen.Dict{
			jen.Id("Address"):   jen.Id("q").Dot("address"),
			jen.Id("QueryData"): jen.Id("rawQueryData"),
		}),
		jen.Id("out").Op(":=").New(jen.Qual("github.com/CosmWasm/wasmd/x/wasm/types", "QuerySmartContractStateResponse")),
		jen.Err().Op(":=").Id("q").Dot("cc").Dot("Invoke").Call(jen.Id("ctx"), jen.Lit("/cosmwasm.wasm.v1.Query/SmartContractState"), jen.Id("in"), jen.Id("out"), jen.Id("opts").Op("...")),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Return(jen.Id("out").Dot("Data"), jen.Nil()),
	)

	for queryName, respSchema := range responses {
		f.Add(generateQueryFunc(queryTitle, queryName, respSchema), jen.Line())
	}
}

func generateQueryInterfaceFunc(queryTitle, queryName string, respSchema *schemas.JSONSchema) []jen.Code {
	pascalName := strcase.ToCamel(queryName)

	reqType := queryTitle + "_" + pascalName
	respType := getResponseName(queryName, respSchema)

	return []jen.Code{
		jen.Comment(fmt.Sprintf("%s is the client API for the %s query message", pascalName, reqType)),
		jen.Id(pascalName).Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("req").Op("*").Id(reqType),
			jen.Id("opts").Op("...").Qual("google.golang.org/grpc", "CallOption"),
		).Params(jen.Op("*").Id(respType), jen.Error()),
	}
}

func generateQueryFunc(queryTitle, queryName string, respSchema *schemas.JSONSchema) jen.Code {
	pascalName := strcase.ToCamel(queryName)

	reqType := queryTitle + "_" + pascalName
	respType := getResponseName(queryName, respSchema)

	return jen.Func().Params(jen.Id("q").Op("*").Id("queryClient")).Id(pascalName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("req").Op("*").Id(reqType),
		jen.Id("opts").Op("...").Qual("google.golang.org/grpc", "CallOption"),
	).Params(jen.Op("*").Id(respType), jen.Error()).Block(
		jen.List(jen.Id("rawQueryData"), jen.Err()).Op(":=").Qual("encoding/json", "Marshal").Call(jen.Id("req")),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Line(),
		jen.List(jen.Id("rawResponseData"), jen.Err()).Op(":=").Id("q").Dot("queryContract").Call(jen.Id("ctx"), jen.Id("rawQueryData"), jen.Id("opts").Op("...")),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Line(),
		jen.Var().Id("response").Id(respType),
		jen.If(jen.Err().Op(":=").Qual("encoding/json", "Unmarshal").Call(jen.Id("rawResponseData"), jen.Op("&").Id("response")), jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Line(),
		jen.Return(jen.Op("&").Id("response"), jen.Nil()),
	)
}

func getResponseName(key string, schema *schemas.JSONSchema) string {
	if len(schema.Type) == 1 && schema.Type[0] == schemas.TypeNameObject {
		title := schema.Title
		if title == "" {
			panic(fmt.Sprintf("response schema for %s must have a title", key))
		}
		duplicate, found := GetDefinition(title)
		if found {
			if duplicate.Description != schema.Description || !slices.Contains([]string{key, schema.Title}, duplicate.Title) {
				title += "_2"
				types.DefaultLogger().Warn().Msgf("found duplicate definition `%s` with differing implementations", schema.Title)
				types.DefaultLogger().Warn().Msgf("renaming the duplicate definition to `%s`", title)
			}
		}

		return title
	}

	allRequired := true
	title, err := getType(key, schema, &allRequired, "")
	if err != nil {
		panic(err)
	}

	return title
}
